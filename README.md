# Experimental Setup

## Target Programs

Adobe Reader v2021.011.20039

Foxit Reader v11.2.1.53537

## Computing Resources

Windows 8.1 virtual machine

One core CPU with 4G memory

Host-machine: 8cores(Intel i7-6700@4.00GHz) and 32G memory

VMware WorkStation

 
# Experimental Data

## Accuracy (Table 1)


### ErrorMessage

#### adobe reader

data/

infered_type/: type information generated by ErrorMessage

ground_truth/: correct type information (from reverse engineering)

utility/

cmp_arg.py: the script file to compare type information

result/

adobe_sample_result.txt: accuracy log file (the detail of accuracy comparasion)

#### foxit reader

data/

infered_type/: type information generated by ErrorMessage

ground_truth/: correct type information (from reverse engineering)

utility/

cmp_arg.py: the script file to compare type information

result/

foxit_sample_result.txt: accuracy log file (the detail of accuracy comparasion)

### PathLength

#### adobe reader

data/

infered_type/: type information generated by PathLength

ground_truth/: correct type information (from reverse engineering)

utility/

cmp_arg.py: the script file to compare type information

result/

adobe_sample_result.txt: accuracy log file (the detail of accuracy comparasion)

#### foxit reader

data/

infered_type/: type information generated by PathLength

ground_truth/: correct type information (from reverse engineering)

utility/

cmp_arg.py: the script file to compare type information

result/

foxit_sample_result.txt: accuracy log file (the detail of accuracy comparasion)

### TypeOracle

#### adobe reader

data/

infered_type/: type information generated by TypeOracle

ground_truth/: correct type information (from reverse engineering)

utility/

cmp_arg.py: the script file to compare type information

result/

adobe_sample_result.txt: accuracy log file (the detail of accuracy comparasion)

#### foxit reader

data/

infered_type/: type information generated by TypeOracle

ground_truth/: correct type information (from reverse engineering)

utility/

cmp_arg.py: the script file to compare type information

result/

foxit_sample_result.txt: accuracy log file (the detail of accuracy comparasion)

### How to reproduce

1. python cmp_arg.py
2. the result will show, comparasion detail is in adobe.txt/foxit.txt

## Fuzzing Performance 

Test cases can be downloaded from https://drive.google.com/file/d/1-zrRJrSwe4MVSnTEpeBduga--ZnP1ZHT/view?usp=sharing.

All files that generated in coverage recording process can be downloaded from https://drive.google.com/file/d/1SUDmnky_Py1rdqMQcPu7rBOBWDD3_7Ll/view?usp=sharing.

Due to the space limitation, we only upload one set of expeirmental data for each experiment.

### Group1: Type Guidance (Figure 7(a), Figure 7(b))
#### adobe reader (Figure 7(a))

We use the random type of documented binding calls, all (documented+undocumented) binding calls, shallow feature(error message and path length), type information of Adobe Manual and type information of TypeOracle to fuzz Adobe and record coverage information using DynamoRIO.

data/:

document: documented binding calls + random testing

random: all binding calls + random testing

error_message: all binding calls + error message

path_len: all binding calls + path length

adobe_manual: documented binding calls + Adobe Manual

typeoracle: all binding calls + TypeOracle

utility/:

draw_all.py: the script file to parse coverage information

result/:

adobe_type.pdf: Figure 7(a)


#### foxit reader (Figure 7(b))

We use the type information of shallow feature(error message and path length), Adobe Document, random type of all (documented+undocumented) binding calls, Adobe's type information of TypeOracle and Foxit's type information of TypeOracle to fuzz Foxit and record coverage information using DynamoRIO

data/:

adobe_manual: fuzzing all binding calls using Adobe Manual

random: randomly fuzzing all (documented+undocumented) binding calls

error_message: all binding calls + error message

path_len: all binding calls + path length

typeoracle_foxit: fuzzing all binding calls using TypeOracle of Foxit

utility/:

draw_all.py: the script file to parse coverage information

result/:

foxit_type.pdf: Figure 7(b)


### Group2: Coverage Guidance (Figure 8(a), Figure 8(b))
#### adobe reader (Figure 8(a))

We use all (documented+undocumented) binding calls, all (documented+undocumented) binding calls with coverage guidance, type information of TypeOracle and type information of TypeOracle with coverage guidance to fuzz Adobe and record coverage information using DynamoRIO.

data/:

random: randomly fuzzing all (documented+undocumented) binding calls

coverage_random: randomly fuzzing all (documented+undocumented) binding calls + coverage guidance

typeoracle: fuzzing all binding calls using TypeOracle

coverage_typeoracle: fuzzing all binding calls using TypeOracle + coverage guidance

utility/:

draw_all.py: the script file to parse coverage information

result/:

adobe_cov.pdf: Figure 8(a)

#### foxit reader (Figure 8(b))

We use all (documented+undocumented) binding calls, all (documented+undocumented) binding calls with coverage guidance, type information of TypeOracle and type information of TypeOracle with coverage guidance to fuzz Foxit and record coverage information using DynamoRIO.

data/:

random: randomly fuzzing all (documented+undocumented) binding calls

coverage_random: randomly fuzzing all (documented+undocumented) binding calls + coverage guidance

typeoracle_foxit: fuzzing all binding calls using TypeOracle

coverage_typeoracle: fuzzing all binding calls using TypeOracle + coverage guidance

utility/:

draw_all.py: the script file to parse coverage information

result/:

foxit_cov.pdf: Figure 8(b)

### Group3: Comparison with State-of-Art Binding Call Fuzzers(Gramatron) (Figure 9(a), Figure 9(b))
#### adobe reader (Figure 9(a))

we use Gramatron, Gramatron with binding calls and TypeOracle to fuzz Adobe and  record coverage information using DynamoRIO

data/:

gramatron: fuzzing using naive Gramatron

gramatron_plus: fuzzing all binding calls using Gramatron 

typeoracle: fuzzing all binding calls using TypeOracle

utility/:

draw_all.py: the script file to parse coverage information

result/:

adobe_gramatron.pdf: Figure 9(a)

#### foxit reader (Figure 9(b))

we use Gramatron, Gramatron with binding calls and TypeOracle to fuzz Foxit and  record coverage information using DynamoRIO

data/:

gramatron: fuzzing using naive Gramatron

gramatron_plus: fuzzing all binding calls using Gramatron 

typeoracle: fuzzing all binding calls using TypeOracle

utility/:

draw_all.py: the script file to parse coverage information

result/:

foxit_gramatron.pdf: Figure 9(b)

### Group3: Integration with State-of-Art Binding Call Fuzzers(Favocado) (Figure 9(c), Figure 9(d))
#### adobe reader (Figure 9(c))

we use Favocado and Favocado with type information of TypeOracle to fuzz Adobe and  record coverage information using DynamoRIO

data/:

favocado: fuzzing all binding calls using Favocado

favocado_typeoracle: fuzzing all binding calls using combination of TypeOracle and Favocado

utility/:

draw_all.py: the script file to parse coverage information

result/:

adobe_favocado.pdf: Figure 9(c)

#### foxit reader (Figure 9(d))

we use Favocado and Favocado with type information of TypeOracle to fuzz Foxit and  record coverage information using DynamoRIO

data/:

favocado: fuzzing all binding calls using Favocado

favocado_typeoracle: fuzzing all binding calls using combination of TypeOracle and Favocado

utility/:

draw_all.py: the script file to parse coverage information

result/:

foxit_favocado.pdf: Figure 9(d)

### Group3: Integration with State-of-Art Binding Call Fuzzers(Cooper) (Figure 9(e), Figure 9(f))
#### adobe reader (Figure 9(e))

we use Cooper and Cooper with type information of TypeOracle to fuzz Adobe and  record coverage information using DynamoRIO

data/:

cooper: fuzzing all binding calls using Cooper

cooper_typeoracle: fuzzing all binding calls using combination of TypeOracle and Cooper

utility/:

draw_all.py: the script file to parse coverage information

result/:

adobe_cooper.pdf: Figure 9(e)


#### foxit reader (Figure 9(f))

we use Cooper and Cooper with type information of TypeOracle to fuzz Foxit and  record coverage information using DynamoRIO

data/:

cooper: fuzzing all binding calls using Cooper

cooper_typeoracle: fuzzing all binding calls using combination of TypeOracle and Cooper

utility/:

draw_all.py: the script file to parse coverage information

result/:

foxit_cooper.pdf: Figure 9(f)

### The way to reproduce

1. python draw_all.py (matplotlib is needed, pip install matplotlib)
2. the result will show

## Vulnerabilities (Table 2)

The PDFs in fuzzing campaign can be downloaded from https://drive.google.com/file/d/1PaDbXew-P-D4wpQ6az3mcykbA89D2a4s/view?usp=sharing.

### adobe reader

All the PoCs that we found on Adobe Reader.

How to reproduce:

1. turn on the page heap: .\gflags.exe /p /enable "C:\Program Files (x86)\Adobe\Acrobat Reader DC\Reader\AcroRd32.exe" 

2. add poc's folder into Adobe's trust path.
Edit->Preferences->Security(Enhanced)->Add Folder Path

3. open the pdf and adobe reader will crash or halt (sometimes you need to close dialog)

For the three Memory Corruption vulnerabilities, you need to use application verifier to detect Adobe Reader.

### foxit reader

All the PoCs that we found on Foxit Reader.

How to reproduce:

1. turn on the page heap: .\gflags.exe /p /enable "C:\Program Files (x86)\Foxit Software\Foxit Reader\FoxitReader.exe"

2. open foxit reader and use windbg to attach it

3. open the pdf and windbg will catch the exception (sometimes you need to close dialog)

